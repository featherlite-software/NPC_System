// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeAI
#pragma kernel CheckRace
#pragma kernel FinalizeData

int2 CellBounds_uAI;
int Step_uAI;
int NpcCount_bNpcSurf;

//RWStructuredBuffer<int> DataNpcId_bAI;
StructuredBuffer<uint> DataNpcSeed_bAI;
RWStructuredBuffer<half2> DataNpcPos_bAI;
RWStructuredBuffer<half2> DataNpcDir_bAI;
RWStructuredBuffer<float3> FinalNpcPos_bAI;
RWStructuredBuffer<int> CellsNpc_bAI;
RWStructuredBuffer<int2> CellsRace_bAI;

int CellPosToIndex(int2 Pos)
{
	return (Pos.y * CellBounds_uAI.x)+Pos.x;
}

float3 CellToWorld(int2 Pos)
{
	return float3(float(Pos.x), 0.0, float(Pos.y));

}

//Pulled off some random place online
//https://www.shadertoy.com/view/4djSRW#

float hash11(float p)
{
	p = frac(p * .1031);
	p *= p + 33.33;
	p *= p + p;
	return frac(p);
}

float hash12(float2 p)
{
	float3 p3 = frac(float3(p.xyx) * .1031);
	p3 += dot(p3, p3.yzx + 33.33);
	return frac((p3.x + p3.y) * p3.z);
}

float2 hash22(float2 p)
{
	float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
	return frac((p3.xx + p3.yz) * p3.zy);

}

bool ValidThread (uint3 ThreadPos) {

	return ThreadPos.x < CellBounds_uAI.x && ThreadPos.y < CellBounds_uAI.y;

}

[numthreads(8,8,1)]
void ComputeAI (uint3 ThreadPos : SV_DispatchThreadID)
{
	if (ValidThread(ThreadPos))
	{
		int2 CellPos = ThreadPos.xy;
		int CellIndex = CellPosToIndex(CellPos);
		
		//CellsRace_bAI[CellIndex] = int2(-1, -1);
		
		if (CellsNpc_bAI[CellIndex] >= 0)
		{
			int NpcId = CellsNpc_bAI[CellIndex];
			uint StepSeed = DataNpcSeed_bAI[NpcId]+Step_uAI;
			float2 CellRandUV = float2(float(CellPos.x), float(CellPos.y)) + float2(float(StepSeed), float(StepSeed)) * float2(1.41421356237, 3.14159);
			float2 MoveHash = hash22(CellRandUV);
			//float HashRange = float(HashFull) / 0xffffffffu;
			int2 Movement = int2(0, 0);
			
			if (MoveHash.x < .33)
			{
				Movement.x = 1;
			}
			else if (MoveHash.x < .66 && MoveHash.x >= .33)
			{
				Movement.x = -1;
			}
			else
			{
				Movement.x = 0;
			}
			if (MoveHash.y < .33)
			{
				Movement.y = 1;
			}
			else if (MoveHash.y < .66 && MoveHash.y >= .33)
			{
				Movement.y = -1;
			}
			else
			{
				Movement.y = 0;
			}
			
			//Movement.x = (HashX < 2147483647u) ? 1 : -1;
			//Movement.y = (HashY < 2147483647u) ? 1 : -1;
			
			//Movement = int2(0, 1);
			DataNpcDir_bAI[NpcId] = float2(0.0,0.0);
			if ((Movement + CellPos).x >= 0 && (Movement + CellPos).x < CellBounds_uAI.x && (Movement + CellPos).y >= 0 && (Movement + CellPos).y < CellBounds_uAI.y)
			{
				//CellsNpc_bAI[CellIndex] = -1;
				//CellsNpc_bAI[CellPosToIndex(Movement + CellPos)] = NpcId;
				DataNpcDir_bAI[NpcId] = float2(float(Movement.x), float(Movement.y));
				CellsRace_bAI[CellIndex].y = NpcId;
				CellsRace_bAI[CellPosToIndex(Movement + CellPos)].x = NpcId;

			}
			//FinalNpcPos_bAI[NpcId] = CellToWorld(CellPos + Movement) + float3(0.0,Step_uAI,0.0);

		}

	}
}

[numthreads(8,8,1)]
void CheckRace(uint3 ThreadPos : SV_DispatchThreadID)
{
	if (ValidThread(ThreadPos))
	{
		int2 CellPos = ThreadPos.xy;
		int MoveIndex = CellPosToIndex(CellPos);
		if (CellsRace_bAI[MoveIndex].x >= 0 && CellsRace_bAI[MoveIndex].y < 0)
		{
			int MoveId = CellsRace_bAI[MoveIndex].x;
			float2 NpcDir = normalize(DataNpcDir_bAI[MoveId]);
			int2 MoveDir;
			NpcDir = float2(clamp(NpcDir.x * 100.0, -1.0, 1.0), clamp(NpcDir.y * 100.0, -1.0, 1.0));
			if (abs(NpcDir.x) < 1.0)
			{
				NpcDir.x = 0;
			}
			if (abs(NpcDir.y) < 1.0)
			{
				NpcDir.y = 0;
			}
			MoveDir = int2(int(NpcDir.x), int(NpcDir.y));

			CellsNpc_bAI[MoveIndex] = MoveId;
			CellsNpc_bAI[MoveIndex + CellPosToIndex(-MoveDir)] = -1;

		}
	}
}

[numthreads(8,8,1)]
void FinalizeData(uint3 ThreadPos : SV_DispatchThreadID)
{
	if (ValidThread(ThreadPos))
	{
		int2 CellPos = ThreadPos.xy;
		int CellIndex = CellPosToIndex(CellPos);
		CellsRace_bAI[CellIndex] = int2(-1, -1);
		if (CellsNpc_bAI[CellIndex] >= 0)
		{
			FinalNpcPos_bAI[CellIndex] = CellToWorld(CellPos);

		}

	}

}
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeAI
#pragma kernel CheckRace

int2 CellBounds_uAI;
int Step_uAI;
int NpcCount_bNpcSurf;

//RWStructuredBuffer<int> DataNpcId_bAI;
StructuredBuffer<uint> DataNpcSeed_bAI;
RWStructuredBuffer<half2> DataNpcPos_bAI;
RWStructuredBuffer<half2> DataNpcDir_bAI;
RWStructuredBuffer<float3> FinalNpcPos_bAI;
RWStructuredBuffer<int> CellsNpc_bAI;
RWStructuredBuffer<int2> CellsRace_bAI;

int CellPosToIndex(int2 Pos)
{
	return (Pos.y * CellBounds_uAI.x)+Pos.x;
}

float3 CellToWorld(int2 Pos)
{
	return float3(float(Pos.x), 0.0, float(Pos.y));

}

//Pulled off some random place online
//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
uint Hash(uint x)
{
	x += (x << 10u);
	x ^= (x >> 6u);
	x += (x << 3u);
	x ^= (x >> 11u);
	x += (x << 15u);
	return x;
}
float FloatConstruct(uint m)
{
	const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
	const uint ieeeOne = 0x3F800000u; // 1.0 in IEEE binary32

	m &= ieeeMantissa; // Keep only mantissa bits (fractional part)
	m |= ieeeOne; // Add fractional part to 1.0

	float f = asfloat(m); // Range [1:2]
	return f - 1.0; // Range [0:1]
}

float RandFloat(int Seed) {
	return FloatConstruct(Hash(Seed));

}

bool ValidThread (uint3 ThreadPos) {

	return ThreadPos.x < CellBounds_uAI.x && ThreadPos.y < CellBounds_uAI.y;

}

[numthreads(8,8,1)]
void ComputeAI (uint3 ThreadPos : SV_DispatchThreadID)
{
	if (ValidThread(ThreadPos))
	{
		int2 CellPos = ThreadPos.xy;
		int CellIndex = CellPosToIndex(CellPos);
		
		if (CellsNpc_bAI[CellIndex] >= 0)
		{
			int NpcId = CellsNpc_bAI[CellIndex];
			uint StepSeed = DataNpcSeed_bAI[NpcId]+Step_uAI;
			float HashX = FloatConstruct(Hash(StepSeed + CellPos.x));
			float HashY = FloatConstruct(Hash(StepSeed + CellPos.y));
			//float HashRange = float(HashFull) / 0xffffffffu;
			int2 Movement = int2(0, 0);
			
			if (HashX < .33)
			{
				Movement.x = 1;
			}
			else if (HashX < .66)
			{
				Movement.x = -1;
			}
			else
			{
				Movement.x = 0;
			}
			if (HashY < .33)
			{
				Movement.y = 1;
			}
			else if (HashY < .66)
			{
				Movement.y = -1;
			}
			else
			{
				Movement.y = 0;
			}
			
			//Movement.x = (HashX < 2147483647u) ? 1 : -1;
			//Movement.y = (HashY < 2147483647u) ? 1 : -1;
			
			//Movement = int2(0, 1);
			
			if ((Movement + CellPos).x >= 0 && (Movement + CellPos).x < CellBounds_uAI.x && (Movement + CellPos).y >= 0 && (Movement + CellPos).y < CellBounds_uAI.y)
			{
				CellsNpc_bAI[CellIndex] = -1;
				CellsNpc_bAI[CellPosToIndex(Movement + CellPos)] = NpcId;
			}
			FinalNpcPos_bAI[NpcId] = CellToWorld(CellPos + Movement) + float3(0.0,Step_uAI,0.0);

		}

	}
}
[numthreads(8,8,1)]
void CheckRace(uint3 ThreadPos : SV_DispatchThreadID)
{
	if (ValidThread(ThreadPos))
	{
		int2 CellPos = ThreadPos.xy;
	}

}
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeAI

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

int2 CellBounds_uAI;

//RWStructuredBuffer<int> DataNpcId_bAI;
StructuredBuffer<uint> DataNpcSeed_bAI;
RWStructuredBuffer<half2> DataNpcPos_bAI;
RWStructuredBuffer<float3> FinalNpcPos_bAI;
RWStructuredBuffer<int> CellsNpc_bAI;
RWStructuredBuffer<int2> DCellsRace_bAI;

int CellPosToIndex(int2 Pos)
{
	return Pos.y * CellBounds_uAI.x + Pos.x;
}

float3 CellToWorld(int2 Pos)
{
	return float3(float(Pos.x), 0.0, float(Pos.y));

}

//Pulled off some random place online
// Hash function from H. Schechter & R. Bridson, goo.gl/RXiKaH
uint Hash(uint s)
{
	s ^= 2747636419u;
	s *= 2654435769u;
	s ^= s >> 16;
	s *= 2654435769u;
	s ^= s >> 16;
	s *= 2654435769u;
	return s;
}

[numthreads(8,8,1)]
void ComputeAI (uint3 ThreadPos : SV_DispatchThreadID)
{
	if (ThreadPos.x < CellBounds_uAI.x && ThreadPos.y < CellBounds_uAI.y)
	{
		int2 CellPos = ThreadPos.xy;
		int CellIndex = CellPosToIndex(CellPos);

		if (CellsNpc_bAI[CellIndex] >= 0)
		{
			FinalNpcPos_bAI[CellsNpc_bAI[CellIndex]] = CellToWorld(CellPos);
		}

	}

}
